import {lib, hterm} from "libapps";

console.log("hterm: before lib.init");
var onInit = ()=>{console.log("lib.init")};
(<any>lib).init(onInit);
console.log("hterm: after lib.init");

export class Hterm {
    elem: HTMLElement;

    term: hterm.Terminal;

    columns: number;
    rows: number;

    // to "show" the current message when removeMessage() is called
    message: string;

    constructor(elem: HTMLElement) {
        this.elem = elem;
    //  var onInit = ()=>{console.log("lib.init")};
    //  (<any>lib).init(onInit);
        hterm.defaultStorage = new lib.Storage.Memory();

        // window.onload = ()=>{(<any>lib).init(onInit)};

        this.term = new hterm.Terminal();
        // this.term.getPrefs().set("send-encoding", "raw");

        this.term.onTerminalReady = () => {
        // // Create a new terminal IO object and give it the foreground.
        // // (The default IO object just prints warning messages about unhandled
        // // things to the the JS console.)
           const io = this.term.io.push();
         
           io.onVTKeystroke = (str) => {
             // Do something useful with str here.
             // For example, Secure Shell forwards the string onto the NaCl plugin.
           };
         
           io.sendString = (str) => {
             // Just like a keystroke, except str was generated by the terminal itself.
             // For example, when the user pastes a string.
             // Most likely you'll do the same thing as onVTKeystroke.
           };
         
           io.onTerminalResize = (columns, rows) => {
             // React to size changes here.
             // Secure Shell pokes at NaCl, which eventually results in
             // some ioctls on the host.
           };
         
        // // You can call io.push() to foreground a fresh io context, which can
        // // be uses to give control of the terminal to something else.  When that
        // // thing is complete, should call io.pop() to restore control to the
        // // previous io object.
        }

        // this.term.decorate(this.elem);
        this.term.decorate(document.querySelector('#terminal'));

        this.term.installKeyboard();
    };

    info(): { columns: number, rows: number } {
        return { columns: this.columns, rows: this.rows };
    };

    output(data: string) {
        if (this.term.io != null) {
            this.term.io.writeUTF8(data);
        }
    };

    showMessage(message: string, timeout: number) {
        this.message = message;
        if (timeout > 0) {
            this.term.io.showOverlay(message, timeout);
        } else {
            this.term.io.showOverlay(message, null);
        }
    };

    removeMessage(): void {
        // there is no hideOverlay(), so show the same message with 0 sec
        this.term.io.showOverlay(this.message, 0);
    }

    setWindowTitle(title: string) {
        this.term.setWindowTitle(title);
    };

    setPreferences(value: object) {
        Object.keys(value).forEach((key) => {
            this.term.getPrefs().set(key, value[key]);
        });
    };

    onInput(callback: (input: string) => void) {
        this.term.io.onVTKeystroke = (data) => {
            callback(data);
        };
        this.term.io.sendString = (data) => {
            callback(data);
        };
    };

    onResize(callback: (colmuns: number, rows: number) => void) {
        this.term.io.onTerminalResize = (columns: number, rows: number) => {
            this.columns = columns;
            this.rows = rows;
            callback(columns, rows);
        };
    };

    deactivate(): void {
        this.term.io.onVTKeystroke    = function(){};
        this.term.io.sendString       = function(){};
        this.term.io.onTerminalResize = function(){};
        this.term.uninstallKeyboard();
    }

    reset(): void {
        this.removeMessage();
        this.term.installKeyboard();
    }

    close(): void {
        this.term.uninstallKeyboard();
    }
}
